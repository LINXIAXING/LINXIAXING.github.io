[{"title":"Docker+FastAPI微服务搭建","url":"/2023/06/07/Docker+FastAPI%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/","content":"\nDocker容器下通过Python fastapi库完成后台，Nginx对不同docker下的服务做端口映射，实现微服务开发。不同的镜像负责不同的功能模块，低耦合高延展，且便于迁移。\n\n\n\nDocker环境搭建\n如果您已准备好容器，请忽略此步\n\n镜像创建与启用准备好镜像后，执行命令启动：\ndocker run -itd --gpus all -e NVIDIA_VISIBLE_DEVICES=all \\-m 128g --cpus=32 --shm-size 64G --name pytorch-container -p 5333:22 \\--ip 172.20.0.1 &lt;image name&gt;:&lt;tag&gt;\n\n–ip 后配置的是容器启动后的IP地址。\n如果忘记可以执行以下命令查看全部容器的地址，或是在容器内部执行ifconfig查看网卡信息：\ndocker inspect -f '{{.Name}} - {{.NetworkSettings.IPAddress }}' $(docker ps -aq)\n\n如果是docker-compose，请使用命令：\ndocker inspect --format='{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq)\n\n完成后在Xftp和Xshell中链接容器。\nNginx端口转发配置转发规则server{  listen 8001;  server_name 127.0.0.1;  location / {    proxy_pass  http://172.11.0.1:8002;    proxy_set_header Host $proxy_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  }}\n\n访问本机8001端口时，将转发到172.11.0.1容器的8002端口\n基于FastApi的后台开发\nFastApi是一个基于Python的高速web框架\n关于更多建议查询官方API，推荐Python版本3.6+\n\n这里我已经写好一份简单的项目。他包含两个接口，通过深度学习模型实现 文字➡语音 和 语音➡文字功能。\n如果要使用，那么你需要拥有基本的CUDA+Pytorch环境，或者你也可以仅做参考。\n详情请访问我的Github仓库。\n在8002端口启动服务。\n","categories":["TECHNOLOGY"],"tags":["Nginx","Docker","FastAPI"]},{"title":"Docker安装","url":"/2022/09/20/Docker%E5%AE%89%E8%A3%85/","content":"Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。\n\n\n安装之前，先卸载已安装的Docker：\nsudo apt-get remove docker docker-engine docker.io\n\nApt-get 安装sudo apt-get updatesudo apt-get install \\\tapt-transport-https \\    ca-certificates \\    curl \\    gnupg \\    lsb-release\n\n为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥：\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | \\\tsudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 官方源# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\#\tsudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n\n向 sources.list 中添加 Docker 软件源：\necho \\\t\"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] \\  \thttps://mirrors.aliyun.com/docker-ce/linux/ubuntu \\\t(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; \\\t/dev/null# 官方源# echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] \\ #\thttps://download.docker.com/linux/ubuntu \\#\t(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; \\ #\t/dev/null\n\n安装：\nsudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\n\n脚本安装curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun\n\n\n\n启动Dockersudo systemctl enable dockersudo systemctl start docker\n\n","categories":["INSTALL"],"tags":["Docker"]},{"title":"Docker command","url":"/2022/09/21/Docker-command/","content":"\n\n\n\n基础命令docker versiondocker infodocker search &lt;镜像名&gt; #查找镜像docker search --filter=STARS=9000 mysql  #搜索 STARS=9000的 mysql 镜像\n\n\n\nImage# 查看全部docker镜像docker images# 拉取tag版本镜像   https://hub.docker.com/search?type=image&amp;q=docker pull &lt;镜像名&gt;:&lt;tag&gt;  # 删除镜像 (后接多个可批量删除,空格隔开docker rmi -f &lt;镜像名/镜像ID&gt;# 保存镜像docker save -o &lt;镜像文件.tar&gt; &lt;镜像名&gt;:&lt;tag&gt;# 加载镜像docker load -i &lt;镜像地址&gt;# 查看镜像详细信息docker inspect &lt;镜像ID&gt;  \n\n\n\nContainer# 查看全部镜像docker ps -a# 基于镜像创建容器docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt;docker run -i -t -v /root/software/:/mnt/software/ 9f38484d220f /bin/bash#\t-i：表示以“交互模式”运行容器#\t-t：表示容器启动后会进入其命令行#\t-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;# 存为镜像docker commit -a \"tropical_algae\" -m \"test\" &lt;container id&gt; &lt;image name&gt;:&lt;tag&gt;#\t-a 提交人的姓名#\t-m 提交内容  现有容器ID#容器重命名docker rename &lt;old&gt; &lt;new&gt;  #启动容器docker start &lt;容器ID&gt;#停止容器docker stop &lt;容器ID&gt;# 删除容器docker rm &lt;容器id&gt;  # 运行容器docker exec -ti --user root &lt;container id&gt; /bin/bash\n\n\n\n我的常用# 深度学习镜像启动docker run -itd \\-p 5444:22 --name &lt;container name&gt; \\--gpus all -e NVIDIA_VISIBLE_DEVICES=all \\-m 128g --cpus=32 --shm-size=64g \\--restart=always \\--device /dev/nvidiactl:/dev/nvidiactl --device /dev/nvidia-uvm:/dev/nvidia-uvm \\--device /dev/nvidia0:/dev/nvidia0 --device /dev/nvidia1:/dev/nvidia1 --device /dev/nvidia2:/dev/nvidia2 --device /dev/nvidia3:/dev/nvidia3 \\-v /datasets/dataset:/dataset:ro \\&lt;image name&gt;:&lt;tag&gt;# 删除全部镜像  -a 意思为显示全部, -q 意思为只显示IDdocker rmi -f $(docker images -aq)# 启动全部容器docker start $(docker ps -a | awk '{ print $1}' | tail -n +2)  \n\n","categories":["DOCUMENT"],"tags":["Docker"]},{"title":"ERROR：在此驱动器上发现潜在错误","url":"/2023/06/15/ERROR%EF%BC%9A%E5%9C%A8%E6%AD%A4%E9%A9%B1%E5%8A%A8%E5%99%A8%E4%B8%8A%E5%8F%91%E7%8E%B0%E6%BD%9C%E5%9C%A8%E9%94%99%E8%AF%AF/","content":"问题描述插入U盘（移动固态）出现错误弹窗提示\n可能是由于文件损坏导致的。初步怀疑是因为我把它插手机上后修改了部分文件 :(\nctrl R打开cmd，执行以下命令修复：\nchkdsk Y:/F/R\t#扫查Y盘\n\n","categories":["ISSUE"],"tags":["windows"]},{"title":"ERROR ：gathering device information while adding custom device dev nvidia-uvm“ no such file or dir","url":"/2023/06/12/ERROR%20%EF%BC%9Agathering%20device%20information%20while%20adding%20custom%20device%20dev%20nvidia-uvm%E2%80%9C%20no%20such%20file%20or%20dir/","content":"“/dev/nvidia-uvm“: no such file or dir 问题解决问题描述\n在搭建使用Docker容器搭建PyTorch容器进行深度学习模型训练时，启动容器报错。\n错误信息如下：\n\n\n在查询相关文档后，尝试以下步骤手动解决：\n解决方案首先确保宿主机已安装nvidia驱动。执行以下命令：\nnvidia-smi\n\n确保显卡没问题，尝试手动加载：\ncd /devnvidia-modprobe -u -c=0ls | grep nvidia\n\nDONE! 问题解决，重启容器即可\n","categories":["ISSUE"],"tags":["Docker","Nvidia"]},{"title":"Linux Screen command","url":"/2023/03/11/Linux-Screen-command/","content":"Primaryscreen [- option] &lt;id&gt;[- option]:    -A\t将所有的视窗都调整为目前终端机的大小。    -d &lt;作业名称&gt;\t将指定的screen作业离线。    -h &lt;行数&gt;\t\t指定视窗的缓冲区行数。    -m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。    -r &lt;作业名称&gt;\t恢复离线的screen作业。    -R\t\t先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。    -s&lt;shell&gt;\t指定建立新视窗时，所要执行的shell。    -S &lt;作业名称&gt;\t指定screen作业的名称。    -v\t显示版本信息。    -x\t恢复之前离线的screen作业。    -ls or --list\t显示目前所有的screen作业。    -wipe\t检查目前所有的screen作业，并删除已经无法使用的screen作业。\n\n\n\nKill screen创建：screen -S &lt;id&gt;查看有多少会话：screen -ls恢复：screen -r &lt;id&gt;如果不能恢复：先screen -d &lt;id&gt;再screen -r &lt;id&gt;删除 screen -S &lt;id&gt; -X quit\n\n","categories":["DOCUMENT"],"tags":["Linux"]},{"title":"Nginx安装","url":"/2020/05/21/Nginx%E5%AE%89%E8%A3%85/","content":"Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，也可以作为反向代理进行负载均衡的实现。\n\n\n在安装之前，你需要先确保你有安装先决条件\n对于Ubuntu：\napt-get install gccapt-get install libpcre3 libpcre3-devapt-get install zlib1g zlib1g-devapt-get install openssl openssl-dev\n\n对于CentOS：\nyum -y install gcc-c++ yum -y install pcre pcre-develyum -y install zlib zlib-develyum -y install openssl openssl-devel  \n\n\n\nLinux下安装访问nginx下载，并将下载好的包上传服务器。或者你可以在服务器上运行以下命令：\nwget http://nginx.org/download/nginx-1.24.0.tar.gz\n\n解压安装包：\ntar -zxvf nginx-1.24.0.tar.gz\n\n进入目录，编译安装：\ncd ./nginx-1.24.0./configuremakemake install\n\n\n走到这步若遇到错误：make: *** No rule to make target build', needed by default’. Stop.\n请检查前面的环境是否已安装。环境配好后重新编译安装\n\n启动Nginx：\nsudo /usr/local/nginx/sbin/nginx\n\n\n\nDocker下安装拉取最新nginx版本：\ndocker pull nginx:latest\n\n运行Docker：\ndocker run -p 9002:80 --name nginx -d nginx:latest\n\n","categories":["INSTALL"],"tags":["Nginx"]},{"title":"*【活动预告】: 全新界面【个人介绍】开启，路由限时开放！","url":"/2099/06/23/%E3%80%90%E6%B4%BB%E5%8A%A8%E9%A2%84%E5%91%8A%E3%80%91-%E5%85%A8%E6%96%B0%E7%95%8C%E9%9D%A2%E3%80%90%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D%E3%80%91%E5%BC%80%E5%90%AF%EF%BC%8C%E8%B7%AF%E7%94%B1%E9%99%90%E6%97%B6%E5%BC%80%E6%94%BE%EF%BC%81/","content":"\n\n\n\n\n\n关于我\n一位年轻有梦想的新晋炼丹师\n\n爱好旁门左道的电子杂食者；梦想是成为精通 ▒ ▒ ▒ ▒ 的 ▒ ▒ ▒ ▒ ▒\n当然这条路还很远 正在一步步接近！\nNULL\n"},{"title":"百度飞桨-PaddleOCR模型微调","url":"/2023/06/05/%E7%99%BE%E5%BA%A6%E9%A3%9E%E6%A1%A8-PaddleOCR%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/","content":"前言最近在用paddle做一个表单图片文字识别的项目，本博客将记录从环境配置到微调完整的流程。\n\n最难的步骤是配环境，环境配不好基本就寄了 :)\n\n\n\n环境准备Docker环境本次是基于Docker的开发环境，请同学帮忙准备了Paddle镜像。您可以在这里下载需要的相关镜像，或是直接将镜像pull到您的服务器中。\n我的环境配置：\npython 3.7\npaddle 2.4.2\ngpu-cuda 11.7\ncudnn 8.4\ntrt 8.4\n准备好镜像后执行命令检查你当前的镜像：\nDocker ps -a\n\n\n\n启动镜像：\ndocker run -itd \\-p 5444:22 --name &lt;container name&gt; \\--gpus all -e NVIDIA_VISIBLE_DEVICES=all \\-m 128g --cpus=32 --shm-size=64g \\--restart=always \\--device /dev/nvidiactl:/dev/nvidiactl --device /dev/nvidia-uvm:/dev/nvidia-uvm \\--device /dev/nvidia0:/dev/nvidia0 --device /dev/nvidia1:/dev/nvidia1 --device /dev/nvidia2:/dev/nvidia2 --device /dev/nvidia3:/dev/nvidia3 \\-v /datasets/dataset:/dataset:ro \\&lt;image name&gt;:&lt;tag&gt;\n\n\n\nPython库配置将Paddle从仓库拉到本地容器：\ngit clone https://github.com/PaddlePaddle/PaddleOCR.git\n\n安装Python依赖库：\npip install -r requirements.txt\n\n\n文件中的库不全，需要补齐依赖\n\npip install Polygon3pip install lanms-proper\n\n\n\n模型微调数据准备使用项目自带的打标程序：\npython .\\PPOCRLabel\\PPOCRLabel.py --lang=ch\n\n\n\n项目下创建文件夹train_data存放训练数据，分出det与rec任务数据，建立训练集和预测集。\n\n\n实践发现文件名不可包含中文，此外txt中路径也需要修改。\n\nimport oschinese = '微信图片'replace_word = 'wxtp'file_names = {    'test_label.txt': 'test_imgs',    'train_label.txt': 'train_imgs'}cache = []# 替换文本内路径与中文名for file_name in file_names.keys():    file = open(file_name, 'r', encoding='utf-8')    lines = file.readlines()    for line in lines:        path = line.split('\\t')[0]        replace_cn = path.replace(chinese, replace_word)        replace_path = replace_cn.replace(replace_cn.split('/')[0], file_names[file_name])        cache.append(line.replace(path, replace_path))    file.close()    file_w = open(file_name, 'w', encoding='utf-8')    for line in cache:        file_w.write(line)    file_w.close()    cache = []# 修改文件名roots = ['./test_imgs', './train_imgs']for root in roots:    files = os.listdir(root)    for name in files:        new_name = name.replace(chinese, replace_word)        old_file = os.path.join(root, name)        new_file = os.path.join(root, new_name)        os.rename(old_file, new_file)\n\n\n\n修改配置文件\ndet使用DB++\t\t下载预训练模型\n\nrec使用CRNN\t\t下载预训练模型\n\n\n需要修改数据集地址，下载预训练模型到pretrained_model，学习率调小等等。\n具体配置如下：\n/PaddleOCR/configs/det/det_r50_db++_icdar15.yml：\nGlobal:  debug: false  use_gpu: true  epoch_num: 600  log_smooth_window: 20  print_batch_step: 10  save_model_dir: ./output/det_r50_icdar15/  save_epoch_step: 200  eval_batch_step:  - 0  - 2000  cal_metric_during_train: false  pretrained_model: ./pretrain_models/ResNet50_dcn_asf_synthtext_pretrained  checkpoints: null  save_inference_dir: null  use_visualdl: false  infer_img: doc/imgs_en/img_10.jpg  save_res_path: ./checkpoints/det_db/predicts_db.txtArchitecture:  model_type: det  algorithm: DB++  Transform: null  Backbone:    name: ResNet    layers: 50    dcn_stage: [False, True, True, True]  Neck:    name: DBFPN    out_channels: 256    use_asf: True  Head:    name: DBHead    k: 50Loss:  name: DBLoss  balance_loss: true  main_loss_type: BCELoss  alpha: 5  beta: 10  ohem_ratio: 3Optimizer:  name: Momentum  momentum: 0.9  lr:    name: DecayLearningRate    learning_rate: 0.007    epochs: 1000    factor: 0.9    end_lr: 0  weight_decay: 0.0001PostProcess:  name: DBPostProcess  thresh: 0.3  box_thresh: 0.6  max_candidates: 1000  unclip_ratio: 1.5  det_box_type: 'quad' # 'quad' or 'poly'Metric:  name: DetMetric  main_indicator: hmeanTrain:  dataset:    name: SimpleDataSet    data_dir: ./train_data/det/    label_file_list:                                                                                                - ./train_data/det/train_label.txt    ratio_list:                                                                                                     - 1.0     transforms:    - DecodeImage:        img_mode: BGR        channel_first: false    - DetLabelEncode: null    - IaaAugment:        augmenter_args:        - type: Fliplr          args:            p: 0.5        - type: Affine          args:            rotate:            - -10            - 10        - type: Resize          args:            size:            - 0.5            - 3    - EastRandomCropData:        size:        - 640        - 640        max_tries: 10        keep_ratio: true    - MakeShrinkMap:        shrink_ratio: 0.4        min_text_size: 8    - MakeBorderMap:        shrink_ratio: 0.4        thresh_min: 0.3        thresh_max: 0.7    - NormalizeImage:        scale: 1./255.        mean:        - 0.48109378172549        - 0.45752457890196        - 0.40787054090196        std:        - 1.0        - 1.0        - 1.0        order: hwc    - ToCHWImage: null    - KeepKeys:        keep_keys:        - image        - threshold_map        - threshold_mask        - shrink_map        - shrink_mask  loader:    shuffle: true    drop_last: false    batch_size_per_card: 4    num_workers: 8Eval:  dataset:    name: SimpleDataSet    data_dir: ./train_data/det/    label_file_list:                                                                                                - ./train_data/det/test_label.txt    transforms:    - DecodeImage:        img_mode: BGR        channel_first: false    - DetLabelEncode: null    - DetResizeForTest:        image_shape:        - 1152        - 2048    - NormalizeImage:        scale: 1./255.        mean:        - 0.48109378172549        - 0.45752457890196        - 0.40787054090196        std:        - 1.0        - 1.0        - 1.0        order: hwc    - ToCHWImage: null    - KeepKeys:        keep_keys:        - image        - shape        - polys        - ignore_tags  loader:    shuffle: false    drop_last: false    batch_size_per_card: 1    num_workers: 2profiler_options: null\n\n\n\n/PaddleOCR/configs/rec/rec_r34_vd_none_bilstm_ctc.yml：\nGlobal:  use_gpu: true  epoch_num: 72  log_smooth_window: 20  print_batch_step: 10  save_model_dir: ./output/rec/r34_vd_none_bilstm_ctc/  save_epoch_step: 3  # evaluation is run every 2000 iterations  eval_batch_step: [0, 2000]  cal_metric_during_train: True  pretrained_model: ./pretrain_models/rec_r34_vd_none_bilstm_ctc_v2.0_train/best_accuracy  checkpoints:  save_inference_dir:  use_visualdl: False  infer_img: doc/imgs_words_en/word_10.png  # for data or label process  character_dict_path:  max_text_length: 25  infer_mode: False  use_space_char: False  save_res_path: ./output/rec/predicts_r34_vd_none_bilstm_ctc.txtOptimizer:  name: Adam  beta1: 0.9  beta2: 0.999  lr:    learning_rate: 0.0005  regularizer:    name: 'L2'    factor: 0Architecture:  model_type: rec  algorithm: CRNN  Transform:  Backbone:    name: ResNet    layers: 34  Neck:    name: SequenceEncoder    encoder_type: rnn    hidden_size: 256  Head:    name: CTCHead    fc_decay: 0Loss:  name: CTCLossPostProcess:  name: CTCLabelDecodeMetric:  name: RecMetric  main_indicator: accTrain:  dataset:    name: SimpleDataSet    data_dir: ./train_data/rec/    label_file_list: [ \"./train_data/rec/rec_gt_train.txt\" ]    transforms:      - DecodeImage: # load image          img_mode: BGR          channel_first: False      - CTCLabelEncode: # Class handling label      - RecResizeImg:          image_shape: [3, 32, 100]      - KeepKeys:          keep_keys: ['image', 'label', 'length'] # dataloader will return list in this order  loader:    shuffle: True    batch_size_per_card: 256    drop_last: True    num_workers: 8Eval:  dataset:    name: SimpleDataSet    data_dir: ./train_data/rec/    label_file_list: [ \"./train_data/rec/rec_gt_test.txt\" ]    transforms:      - DecodeImage: # load image          img_mode: BGR          channel_first: False      - CTCLabelEncode: # Class handling label      - RecResizeImg:          image_shape: [3, 32, 100]      - KeepKeys:          keep_keys: ['image', 'label', 'length'] # dataloader will return list in this order  loader:    shuffle: False    drop_last: False    batch_size_per_card: 256    num_workers: 4\n\n\n\n训练Det文本检测单机单卡训练：\npython tools/train.py -c configs/det/det_r50_db++_icdar15.yml\n\n单机多卡训练：\npython -m paddle.distributed.launch --gpus '0,1,2,3' tools/train.py \\ -c configs/det/det_r50_db++_icdar15.yml\n\n多机多卡训练：\npython -m paddle.distributed.launch --ips=\"xx.xx.xx.xx,xx.xx.xx.xx\" \\--gpus '0,1,2,3' tools/train.py -c configs/det/det_r50_db++_icdar15.yml\n\n\n\n评估：\npython3 tools/eval.py -c configs/det/det_mv3_db.yml  -o Global.checkpoints=\"{path/to/weights}/best_accuracy\"\n\n\n\n\n\nRec文本识别单机单卡：\npython3 tools/train.py -c configs/rec/rec_r34_vd_none_bilstm_ctc.yml\n\n单机多卡：\npython3 -m paddle.distributed.launch --gpus '0,1,2,3' tools/train.py \\-c configs/rec/rec_r34_vd_none_bilstm_ctc.yml\n\n评估：\npython3 -m paddle.distributed.launch --gpus '0' tools/eval.py \\-c configs/rec/rec_r34_vd_none_bilstm_ctc.yml \\-o Global.pretrained_model={path/to/weights}/best_accuracy\n\n模型测试模型导出Det模型python3 tools/export_model.py -c configs/det/det_mv3_db.yml -o \\Global.pretrained_model=\"./output/det_r50_icdar15/best_accuracy\" \\Global.save_inference_dir=\"./inference/det_db_inference/\"\n\n\n\nRec模型python3 tools/export_model.py -c configs/rec/rec_r34_vd_none_bilstm_ctc.yml \\-o Global.pretrained_model=\"./output/rec/r34_vd_none_bilstm_ctc/best_accuracy\" \\Global.save_inference_dir=\"./inference/rec_crnn\"\n\n\n\n替换权重定位源码，默认的权重加载/下载路径在home目录下的./paddleocr下\n\n\n\nWindows 用户：C:\\Users\\XXX\\.paddleocr\\whl\nLinux root用户：/root/.paddleocr/whl\n将上面导出的权重替换到对应文件夹下\n识别测试img_path = './test.jpg'ocr = PaddleOCR(use_angle_cls=True, use_gpu=False,lang=\"ch\")  # need to run only once to download and load model into memoryresult = ocr.ocr(img_path, det=True, cls=False, rec=True)# 预测结果包含识别BOX的位置信息，文字以及置信度# [[[x, y]]*4, (word, confidence)]for line in result[0]:\tprint(line)image = Image.open(img_path).convert('RGB')boxes = [line[0] for line in result[0]]txts = [line[1][0] for line in result[0]]scores = [line[1][1] for line in result[0]]im_show = draw_ocr(image, boxes, txts, scores)im_show = Image.fromarray(im_show)im_show.save('./result.jpg')\n\n这是一份基础的测试代码，后续将更新更完整的Acc测试脚本\n","categories":["TECHNOLOGY"],"tags":["Deep Learning","OCR","Paddle"]},{"title":"【转】23种设计模式","url":"/2020/03/21/%E3%80%90%E8%BD%AC%E3%80%9123%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"\n转载文章，复习回顾用\n原文地址：点击此处\n\n设计模式的分类总体来说设计模式分为三大类：\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n创建模式（5种）工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n工厂模式简单工厂模式定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为。\n举例：（我们举一个pizza工厂的例子）\npizza工厂一共生产三种类型的pizza：chesse,pepper,greak。通过工厂类（SimplePizzaFactory）实例化这三种类型的对象。类图如下：\n工厂类的代码：\n`public class SimplePizzaFactory {       public Pizza CreatePizza(String ordertype) {              Pizza pizza = null;              if (ordertype.equals(\"cheese\")) {                     pizza = new CheesePizza();              } else if (ordertype.equals(\"greek\")) {                     pizza = new GreekPizza();              } else if (ordertype.equals(\"pepper\")) {                     pizza = new PepperPizza();              }              return pizza;       }}\n\n简单工厂存在的问题与解决方法： 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式。\n工厂方法模式定义：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。\n举例：（我们依然举pizza工厂的例子，不过这个例子中，pizza产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的if else语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦敦工厂。类图如下：  OrderPizza中有个抽象的方法：\nabstract Pizza createPizza();两个工厂类继承OrderPizza并实现抽象方法：\npublic class LDOrderPizza extends OrderPizza {       Pizza createPizza(String ordertype) {              Pizza pizza = null;              if (ordertype.equals(\"cheese\")) {                     pizza = new LDCheesePizza();              } else if (ordertype.equals(\"pepper\")) {                     pizza = new LDPepperPizza();              }              return pizza;       }}public class NYOrderPizza extends OrderPizza { \tPizza createPizza(String ordertype) {\t\tPizza pizza = null; \t\tif (ordertype.equals(\"cheese\")) {\t\t\tpizza = new NYCheesePizza();\t\t} else if (ordertype.equals(\"pepper\")) {\t\t\tpizza = new NYPepperPizza();\t\t}\t\treturn pizza; \t} }\n\n通过不同的工厂会得到不同的实例化的对象，PizzaStroe的代码如下：\npublic class PizzaStroe {       public static void main(String[] args) {              OrderPizza mOrderPizza;              mOrderPizza = new NYOrderPizza();       }}\n\n解决了简单工厂模式的问题：增加一个新的pizza产地（北京），只要增加一个BJOrderPizza类：\npublic class BJOrderPizza extends OrderPizza {       Pizza createPizza(String ordertype) {              Pizza pizza = null;              if (ordertype.equals(\"cheese\")) {                     pizza = new LDCheesePizza();              } else if (ordertype.equals(\"pepper\")) {                     pizza = new LDPepperPizza();              }              return pizza;       }}\n\n其实这个模式的好处就是，如果你现在想增加一个功能，只需做一个实现类就OK了，无需去改动现成的代码。这样做，拓展性较好！\n工厂方法存在的问题与解决方法：客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。\n抽象工厂模式定义：定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。\n举例：（我们依然举pizza工厂的例子，pizza工厂有两个：纽约工厂和伦敦工厂）。类图如下：\n工厂的接口：\npublic interface AbsFactory {       Pizza CreatePizza(String ordertype) ;}\n\n工厂的实现：\npublic class LDFactory implements AbsFactory {       @Override       public Pizza CreatePizza(String ordertype) {              Pizza pizza = null;              if (\"cheese\".equals(ordertype)) {                     pizza = new LDCheesePizza();              } else if (\"pepper\".equals(ordertype)) {                     pizza = new LDPepperPizza();              }              return pizza;       }}\n\nPizzaStroe的代码如下：\npublic class PizzaStroe {       public static void main(String[] args) {              OrderPizza mOrderPizza;              mOrderPizza = new OrderPizza(\"London\");       }}\n\n解决了工厂方法模式的问题：在抽象工厂中PizzaStroe中只需要传入参数就可以实例化对象。\n工厂模式适用的场合大量的产品需要创建，并且这些产品具有共同的接口 。\n三种工厂模式的使用选择简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）\n工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）\n抽象工厂 ：用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）\n简单工厂的适用场合：只有伦敦工厂（只有这一个等级），并且这个工厂只生产三种类型的pizza：chesse,pepper,greak（固定产品）。\n工厂方法的适用场合：现在不光有伦敦工厂，还增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂依然只生产三种类型的pizza：chesse,pepper,greak（固定产品）。\n抽象工厂的适用场合：不光增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂还增加了一种新的类型的pizza：chinese pizza（增加产品族）。\n所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。因此，我们可以用抽象工厂模式创建工厂，而用工厂方法模式创建生产线。比如，我们可以使用抽象工厂模式创建伦敦工厂和纽约工厂，使用工厂方法实现cheese pizza和greak pizza的生产。类图如下：\n总结一下三种模式：\n简单工厂模式就是建立一个实例化对象的类，在该类中对多个对象实例化。工厂方法模式是定义了一个创建对象的抽象方法，由子类决定要实例化的类。这样做的好处是再有新的类型的对象需要实例化只要增加子类即可。抽象工厂模式定义了一个接口用于创建对象族，而无需明确指定具体类。抽象工厂也是把对象的实例化交给了子类，即支持拓展。同时提供给客户端接口，避免了用户直接操作子类工厂。  \n单例模式定义：确保一个类最多只有一个实例，并提供一个全局访问点\n单例模式可以分为两种：预加载和懒加载\n预加载顾名思义，就是预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。\npublic class PreloadSingleton {              public static PreloadSingleton instance = new PreloadSingleton();          //其他的类无法实例化单例类的对象       private PreloadSingleton() {       };              public static PreloadSingleton getInstance() {              return instance;       }}\n\n很明显，没有使用该单例对象，该对象就被加载到了内存，会造成内存的浪费。\n懒加载为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。\npublic class Singleton {              private static Singleton instance=null;              private Singleton(){       };              public static Singleton getInstance()       {              if(instance==null)              {                     instance=new Singleton();              }              return instance;                     }}\n\n单例模式和线程安全（1）预加载只有一条语句return instance,这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。\n（2）懒加载不浪费内存，但是无法保证线程的安全。首先，if判断以及其内存执行代码是非原子性的。其次，new Singleton()无法保证执行的顺序性。\n不满足原子性或者顺序性，线程肯定是不安全的，这是基本的常识，不再赘述。我主要讲一下为什么new Singleton()无法保证顺序性。我们知道创建一个对象分三步:\nmemory=allocate();//1:初始化内存空间 ctorInstance(memory);//2:初始化对象instance=memory();//3:设置instance指向刚分配的内存地址\n\njvm为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面2和3行代码可能被重新排序。我们用两个线程来说明线程是不安全的。线程A和线程B都创建对象。其中，A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象（线程不安全）。\n\n保证懒加载的线程安全我们首先想到的就是使用synchronized关键字。synchronized加载getInstace()函数上确实保证了线程的安全。但是，如果要经常的调用getInstance()方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用synchronized加锁，直接返回对象。\npublic class Singleton {       private static Singleton instance = null;       private Singleton() {       };       public static synchronized Singleton getInstance() {              if (instance == null) {                     instance = new Singleton();              }              return instance;       }}\n\n我们把sychronized加在if(instance==null)判断语句里面，保证instance未实例化的时候才加锁\npublic class Singleton {       private static Singleton instance = null;       private Singleton() {       };       public static synchronized Singleton getInstance() {              if (instance == null) {                     synchronized (Singleton.class) {                           if (instance == null) {                                  instance = new Singleton();                           }                     }              }              return instance;       }}\n\n我们经过2.3的讨论知道new一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字volatile保证对象实例化过程的顺序性。\npublic class Singleton {       private static volatile Singleton instance = null;       private Singleton() {       };       public static synchronized Singleton getInstance() {              if (instance == null) {                     synchronized (instance) {                           if (instance == null) {                                  instance = new Singleton();                           }                     }              }              return instance;       }}\n\n到此，我们就保证了懒加载的线程安全。\n生成器模式定义：封装一个复杂对象构造过程，并允许按步骤构造。\n定义解释： 我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。\n模式的结构和代码示例生成器模式结构中包括四种角色：\n（1）产品(Product)：具体生产器要构造的复杂对象；\n（2）抽象生成器(Bulider)：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（定义构造步骤）；\n（3）具体生产器(ConcreteBuilder)：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法（生产各个组件）；\n（4）指挥者(Director)：指挥者是一个类，该类需要含有Builder接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。（按照步骤组装部件，并返回Product）\n举例（我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标)\n虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。类图如下：\nComputerBuilder类定义构造步骤：\npublic abstract class ComputerBuilder {       protected Computer computer;       public Computer getComputer() {        return computer;    }       public void buildComputer() {        computer = new Computer();        System.out.println(\"生成了一台电脑！！！\");    }    public abstract void buildMaster();    public abstract void buildScreen();    public abstract void buildKeyboard();    public abstract void buildMouse();    public abstract void buildAudio();}\n\nHPComputerBuilder定义各个组件：\npublic class HPComputerBuilder extends ComputerBuilder {    @Override    public void buildMaster() {        // TODO Auto-generated method stub        computer.setMaster(\"i7,16g,512SSD,1060\");        System.out.println(\"(i7,16g,512SSD,1060)的惠普主机\");    }    @Override    public void buildScreen() {        // TODO Auto-generated method stub        computer.setScreen(\"1080p\");        System.out.println(\"(1080p)的惠普显示屏\");    }    @Override    public void buildKeyboard() {        // TODO Auto-generated method stub        computer.setKeyboard(\"cherry 青轴机械键盘\");        System.out.println(\"(cherry 青轴机械键盘)的键盘\");    }    @Override    public void buildMouse() {        // TODO Auto-generated method stub        computer.setMouse(\"MI 鼠标\");        System.out.println(\"(MI 鼠标)的鼠标\");    }    @Override    public void buildAudio() {        // TODO Auto-generated method stub        computer.setAudio(\"飞利浦 音响\");        System.out.println(\"(飞利浦 音响)的音响\");    }}\n\nDirector类对组件进行组装并生成产品\npublic class Director {       private ComputerBuilder computerBuilder;    public void setComputerBuilder(ComputerBuilder computerBuilder) {        this.computerBuilder = computerBuilder;    }       public Computer getComputer() {        return computerBuilder.getComputer();    }       public void constructComputer() {        computerBuilder.buildComputer();        computerBuilder.buildMaster();        computerBuilder.buildScreen();        computerBuilder.buildKeyboard();        computerBuilder.buildMouse();        computerBuilder.buildAudio();    }}\n\n生成器模式的优缺点优点：将一个对象分解为各个组件\n将对象组件的构造封装起来\n可以控制整个对象的生成过程\n缺点：对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量\n生成器模式与工厂模式的不同生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。  \n原型模式定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。\n简单地理解，其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会clone一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：Clone。\n深拷贝和浅拷贝浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。\n深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的\n原型模式的结构和代码示例\nClient：使用者\nPrototype：接口（抽象类），声明具备clone能力，例如java中得Cloneable接口\nConcretePrototype：具体的原型类\n可以看出设计模式还是比较简单的，重点在于Prototype接口和Prototype接口的实现类ConcretePrototype。原型模式的具体实现：一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法。\npublic class Prototype implements Cloneable {  \tpublic Object clone() throws CloneNotSupportedException {  \t\tPrototype proto = (Prototype) super.clone();  \t\treturn proto;  \t}  }\n\n举例（银行发送大量邮件，使用clone和不使用clone的时间对比）：我们模拟创建一个对象需要耗费比较长的时间，因此，在构造函数中我们让当前线程sleep一会\npublic Mail(EventTemplate et) {        this.tail = et.geteventContent();        this.subject = et.geteventSubject();        try {        Thread.sleep(1000);        } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();        }}\n\n不使用clone,发送十个邮件\npublic static void main(String[] args) {              int i = 0;              int MAX_COUNT = 10;              EventTemplate et = new EventTemplate(\"9月份信用卡账单\", \"国庆抽奖活动...\");              long start = System.currentTimeMillis();              while (i &lt; MAX_COUNT) {                     // 以下是每封邮件不同的地方                     Mail mail = new Mail(et);                     mail.setContent(getRandString(5) + \",先生（女士）:你的信用卡账单...\" + mail.getTail());                     mail.setReceiver(getRandString(5) + \"@\" + getRandString(8) + \".com\");                     // 然后发送邮件                     sendMail(mail);                     i++;              }              long end = System.currentTimeMillis();              System.out.println(\"用时:\" + (end - start));       }\n\n用时：10001\n使用clone,发送十个邮件\npublic static void main(String[] args) {             int i = 0;             int MAX_COUNT = 10;             EventTemplate et = new EventTemplate(\"9月份信用卡账单\", \"国庆抽奖活动...\");             long start=System.currentTimeMillis();             Mail mail = new Mail(et);                      while (i &lt; MAX_COUNT) {                    Mail cloneMail = mail.clone();                    mail.setContent(getRandString(5) + \",先生（女士）:你的信用卡账单...\"                                 + mail.getTail());                    mail.setReceiver(getRandString(5) + \"@\" + getRandString(8) + \".com\");                    sendMail(cloneMail);                    i++;             }             long end=System.currentTimeMillis();             System.out.println(\"用时:\"+(end-start));      }\n\n用时：1001\n总结原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。\n结构模式（7种）适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n适配器模式定义： 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。\n主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。\n类适配器模式通过多重继承目标接口和被适配者类方式来实现适配\n举例(将USB接口转为VGA接口)，类图如下：\nUSBImpl的代码：\npublic class USBImpl implements USB{       @Override       public void showPPT() {              // TODO Auto-generated method stub              System.out.println(\"PPT内容演示\");       }}\n\nAdatperUSB2VGA 首先继承USBImpl获取USB的功能，其次，实现VGA接口，表示该类的类型为VGA。\npublic class AdapterUSB2VGA extends USBImpl implements VGA {       @Override       public void projection() {              super.showPPT();       }}\n\nProjector将USB映射为VGA，只有VGA接口才可以连接上投影仪进行投影\npublic class Projector&lt;T&gt; {       public void projection(T t) {              if (t instanceof VGA) {                     System.out.println(\"开始投影\");                     VGA v = new VGAImpl();                     v = (VGA) t;                     v.projection();              } else {                     System.out.println(\"接口不匹配，无法投影\");              }       }}\n\ntest代码\n@Testpublic void test2(){\t//通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法\tVGA a=new AdapterUSB2VGA();\t//进行投影\tProjector p1=new Projector();\tp1.projection(a);}\n\n对象适配器模式对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。\n举例(将USB接口转为VGA接口)，类图如下：\n\npublic class AdapterUSB2VGA implements VGA {       USB u = new USBImpl();       @Override       public void projection() {              u.showPPT();       }}\n\n实现VGA接口，表示适配器类是VGA类型的，适配器方法中直接使用USB对象。\n接口适配器模式当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。\n举例(将USB接口转为VGA接口，VGA中的b()和c()不会被实现)，类图如下：\nAdapterUSB2VGA抽象类\npublic abstract class AdapterUSB2VGA implements VGA {       USB u = new USBImpl();       @Override       public void projection() {              u.showPPT();       }       @Override       public void b() {       };       @Override       public void c() {       };}\n\nAdapterUSB2VGA实现，不用去实现b()和c()方法。\npublic class AdapterUSB2VGAImpl extends AdapterUSB2VGA {       public void projection() {              super.projection();       }}\n\n总结总结一下三种适配器模式的应用场景：\n类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。\n对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。\n接口适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。\n命名规则：\n我个人理解，三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。\n类适配器，以类给到，在Adapter里，就是将src当做类，继承，\n对象适配器，以对象给到，在Adapter里，将src作为一个对象，持有。\n接口适配器，以接口给到，在Adapter里，将src作为一个接口，实现。\n使用选择：\n根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。  \n装饰者模式定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。\n装饰者模式结构图与代码示例1.Component（被装饰对象的基类）\n定义一个对象接口，可以给这些对象动态地添加职责。\n2.ConcreteComponent（具体被装饰对象）\n定义一个对象，可以给这个对象添加一些职责。\n3.Decorator（装饰者抽象类）\n维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。\n4.ConcreteDecorator（具体装饰者）\n具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。\n被装饰对象和修饰者继承自同一个超类 \n举例(咖啡馆订单项目：1）、咖啡种类：Espresso、ShortBlack、LongBlack、Decaf2）、调料（装饰者）：Milk、Soy、Chocolate)，类图如下：被装饰的对象和装饰者都继承自同一个超类\npublic abstract class Drink {       public String description=\"\";       private float price=0f;;                     public void setDescription(String description)       {              this.description=description;       }              public String getDescription()       {              return description+\"-\"+this.getPrice();       }       public float getPrice()       {              return price;       }       public void setPrice(float price)       {              this.price=price;       }       public abstract float cost();       }\n\n被装饰的对象，不用去改造。原来怎么样写，现在还是怎么写。\npublic  class Coffee extends Drink {       @Override       public float cost() {              // TODO Auto-generated method stub              return super.getPrice();       }       }\n\ncoffee类的实现\npublic class Decaf extends Coffee {       public Decaf()       {              super.setDescription(\"Decaf\");              super.setPrice(3.0f);       }}\n\n装饰者\n装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为coffee+milk。再加牛奶价格为coffee+milk+chocolate。\npublic class Decorator extends Drink {       private Drink Obj;       public Decorator(Drink Obj) {              this.Obj = Obj;       };       @Override       public float cost() {              // TODO Auto-generated method stub              return super.getPrice() + Obj.cost();       }       @Override       public String getDescription() {              return super.description + \"-\" + super.getPrice() + \"&amp;&amp;\" + Obj.getDescription();       }}\n\n装饰者实例化（加牛奶）。这里面要对被修饰的对象进行实例化。\npublic class Milk extends Decorator {       public Milk(Drink Obj) {                        super(Obj);              // TODO Auto-generated constructor stub              super.setDescription(\"Milk\");              super.setPrice(2.0f);       }}\n\ncoffee店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰。\npublic class CoffeeBar {       public static void main(String[] args) {              Drink order;              order = new Decaf();              System.out.println(\"order1 price:\" + order.cost());              System.out.println(\"order1 desc:\" + order.getDescription());              System.out.println(\"****************\");              order = new LongBlack();              order = new Milk(order);              order = new Chocolate(order);              order = new Chocolate(order);              System.out.println(\"order2 price:\" + order.cost());              System.out.println(\"order2 desc:\" + order.getDescription());       }}\n\n总结装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。如果是用继承,每当需要增加新的行为时,就要修改原程序了。\n代理模式定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。\n举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：\n\n为什么要用代理模式？中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。\n开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。\n代理模式分为三类：1. 静态代理 2. 动态代理 3. CGLIB代理\n静态代理举例(买房），类图如下：\n第一步：创建服务类接口\npublic interface BuyHouse {    void buyHosue();}\n\n第二步：实现服务接口\npublic class BuyHouseImpl implements BuyHouse {       @Override       public void buyHosue() {              System.out.println(\"我要买房\");       }}\n\n第三步：创建代理类\npublic class BuyHouseProxy implements BuyHouse {       private BuyHouse buyHouse;       public BuyHouseProxy(final BuyHouse buyHouse) {              this.buyHouse = buyHouse;       }       @Override       public void buyHosue() {              System.out.println(\"买房前准备\");              buyHouse.buyHosue();              System.out.println(\"买房后装修\");       }}\n\n总结：\n优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。\n缺点： 代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。\n动态代理动态代理有以下特点:\n1.代理对象,不需要实现接口\n2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)\n代理类不用再实现接口了。但是，要求被代理对象必须有接口。\n动态代理实现：\nJava.lang.reflect.Proxy类可以直接生成一个代理对象\nProxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)生成一个代理对象\n参数1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器\n参数2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口\n参数3:InvocationHandler h (接口)执行处理类\nInvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：调用代理类的任何方法，此方法都会执行\n参数3.1:代理对象(慎用)\n参数3.2:当前执行的方法\n参数3.3:当前执行的方法运行时传递过来的参数\n第一步：编写动态处理器\npublic class DynamicProxyHandler implements InvocationHandler {       private Object object;       public DynamicProxyHandler(final Object object) {              this.object = object;       }       @Override       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {              System.out.println(\"买房前准备\");              Object result = method.invoke(object, args);              System.out.println(\"买房后装修\");              return result;       }}\n\n第二步：编写测试类\npublic class DynamicProxyTest {    public static void main(String[] args) {        BuyHouse buyHouse = new BuyHouseImpl();        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new                Class[]{BuyHouse.class}, new DynamicProxyHandler(buyHouse));        proxyBuyHouse.buyHosue();    }}\n\n动态代理总结：虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏（我们要使用被代理的对象的接口），因为它的设计注定了这个遗憾。\nCGLIB代理CGLIB 原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。\nCGLIB 底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。\nCGLIB缺点：对于final方法，无法进行代理。\nCGLIB的实现步骤：\n第一步：建立拦截器\npublic Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {         System.out.println(\"买房前准备\");         Object result = methodProxy.invoke(object, args);         System.out.println(\"买房后装修\");         return result;     }\n\n参数：Object为由CGLib动态生成的代理类实例，Method为上文中实体类所调用的被代理的方法引用，Object[]为参数值列表，MethodProxy为生成的代理类对方法的代理引用。\n返回：从代理实例的方法调用返回的值。\n其中，proxy.invokeSuper(obj,arg) 调用代理类实例上的proxy方法的父类方法（即实体类TargetObject中对应的方法）\n第二步： 生成动态代理类\npublic class CglibProxy implements MethodInterceptor {    private Object target;    public Object getInstance(final Object target) {        this.target = target;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(this.target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(\"买房前准备\");        Object result = methodProxy.invoke(object, args);        System.out.println(\"买房后装修\");        return result;    }}\n\n这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。\n首先将被代理类TargetObject设置成父类，然后设置拦截器TargetInterceptor，最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型TargetObject。\n第三步：测试\npublic class CglibProxyTest {    public static void main(String[] args){        BuyHouse buyHouse = new BuyHouseImpl();        CglibProxy cglibProxy = new CglibProxy();        BuyHouseImpl buyHouseCglibProxy = (BuyHouseImpl) cglibProxy.getInstance(buyHouse);        buyHouseCglibProxy.buyHosue();    }}\n\nCGLIB代理总结： CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。\n外观模式定义： 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n模式结构和代码示例\n简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到3个角色。\n1）.门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（客户调用，同时自身调用子系统功能）\n2）.子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）\n3）.客户角色:通过调用Facede来完成要实现的功能（调用门面角色）。\n举例（每个Computer都有CPU、Memory、Disk。在Computer开启和关闭的时候，相应的部件也会开启和关闭），类图如下： \n首先是子系统类：\npublic class CPU { \tpublic void start() {\t\tSystem.out.println(\"cpu is start...\");\t} \tpublic void shutDown() {\t\tSystem.out.println(\"CPU is shutDown...\");\t}} public class Disk {\tpublic void start() {\t\tSystem.out.println(\"Disk is start...\");\t} \tpublic void shutDown() {\t\tSystem.out.println(\"Disk is shutDown...\");\t}} public class Memory {\tpublic void start() {\t\tSystem.out.println(\"Memory is start...\");\t} \tpublic void shutDown() {\t\tSystem.out.println(\"Memory is shutDown...\");\t}}\n\n然后是，门面类Facade\npublic class Computer { \tprivate CPU cpu;\tprivate Memory memory;\tprivate Disk disk; \tpublic Computer() {\t\tcpu = new CPU();\t\tmemory = new Memory();\t\tdisk = new Disk();\t} \tpublic void start() {\t\tSystem.out.println(\"Computer start begin\");\t\tcpu.start();\t\tdisk.start();\t\tmemory.start();\t\tSystem.out.println(\"Computer start end\");\t} \tpublic void shutDown() {\t\tSystem.out.println(\"Computer shutDown begin\");\t\tcpu.shutDown();\t\tdisk.shutDown();\t\tmemory.shutDown();\t\tSystem.out.println(\"Computer shutDown end...\");\t}}\n\n最后为，客户角色\npublic class Client { \tpublic static void main(String[] args) {\t\tComputer computer = new Computer();\t\tcomputer.start();\t\tSystem.out.println(\"=================\");\t\tcomputer.shutDown();\t} }\n\n优点　　- 松散耦合\n使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；\n\n简单易用\n\n客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。\n\n更好的划分访问层次\n\n有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。\n桥接模式定义： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n案例看下图手机与手机软件的类图  增加一款新的手机软件，需要在所有手机品牌类下添加对应的手机软件类，当手机软件种类较多时，将导致类的个数急剧膨胀，难以维护\n\n手机和手机中的软件是什么关系？\n手机中的软件从本质上来说并不是一种手机，手机软件运行在手机中，是一种包含与被包含关系，而不是一种父与子或者说一般与特殊的关系，通过继承手机类实现手机软件类的设计是违反一般规律的。\n如果Oppo手机实现了wifi功能，继承它的Oppo应用商城也会继承wifi功能，并且Oppo手机类的任何变动，都会影响其子类\n换一种解决思路  \n从类图上看起来更像是手机软件类图，涉及到手机本身相关的功能，比如说：wifi功能，放到哪个类中实现呢？放到OppoAppStore中实现显然是不合适的\n引起整个结构变化的元素有两个，一个是手机品牌，一个是手机软件，所以我们将这两个点抽出来，分别进行封装\n9.2 桥接模式结构和代码示例\n类图：\n实现：\npublic interface Software {\tpublic void run(); }public class AppStore implements Software {\t     @Override    public void run() {        System.out.println(\"run app store\");    }}public class Camera implements Software {\t     @Override    public void run() {        System.out.println(\"run camera\");    }}\n\n抽象：\npublic abstract class Phone { \tprotected Software software; \tpublic void setSoftware(Software software) {\t\tthis.software = software;\t} \tpublic abstract void run(); }public class Oppo extends Phone {\t     @Override    public void run() {        software.run();    }}public class Vivo extends Phone {\t     @Override    public void run() {        software.run();    }}\n\n对比最初的设计，将抽象部分（手机）与它的实现部分（手机软件类）分离，将实现部分抽象成单独的类，使它们都可以独立地变化。整个类图看起来像一座桥，所以称为桥接模式\n继承是一种强耦合关系，子类的实现与它的父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化，因此继承或者说强耦合关系严重影响了类的灵活性，并最终限制了可复用性\n从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互相影响\n适用场景桥接模式通常适用于以下场景。\n当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。\n当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。\n当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。\n优缺点优点：\n(1)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。\n(2)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。\n缺点：\n桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。\n组合模式定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。\n意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。\n关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。\n组合模式的主要优点有：\n组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；\n更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；\n其主要缺点是：\n设计较复杂，客户端需要花更多时间理清类之间的层次关系；\n不容易限制容器中的构件；\n不容易用继承的方法来增加构件的新功能；  \n模式结构和代码示例\n抽象构件（Component)角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。\n树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。\n树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法\n举例（访问一颗树），类图如下：\n1 组件\npublic interface Component {    public void add(Component c);    public void remove(Component c);    public Component getChild(int i);    public void operation(); }\n\n2 叶子\npublic class Leaf implements Component{    \tprivate String name;\t\t\tpublic Leaf(String name) {\t\tthis.name = name;\t} \t@Override\tpublic void add(Component c) {} \t@Override\tpublic void remove(Component c) {} \t@Override\tpublic Component getChild(int i) {\t\t// TODO Auto-generated method stub\t\treturn null;\t} \t@Override\tpublic void operation() {\t\t// TODO Auto-generated method stub\t\t System.out.println(\"树叶\"+name+\"：被访问！\"); \t} }\n\n3 树枝\npublic class Composite implements Component { \tprivate ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;(); \tpublic void add(Component c) {\t\tchildren.add(c);\t} \tpublic void remove(Component c) {\t\tchildren.remove(c);\t} \tpublic Component getChild(int i) {\t\treturn children.get(i);\t} \tpublic void operation() {\t\tfor (Object obj : children) {\t\t\t((Component) obj).operation();\t\t}\t}}\n\n享元模式定义：通过共享的方式高效的支持大量细粒度的对象。\n主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。\n何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。\n如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。\n关键代码：用 HashMap 存储这些对象。\n应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。\n优点：大大减少对象的创建，降低系统的内存，使效率提高。\n缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。\n简单来说，我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。\n享元模式的结构图和代码示例  \n1、Flyweight (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。\n2、ConcreteFlyweight(具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。\n3、FlyweightFactory(享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成键值对，或者其他的存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。\n举例（JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面）。类图如下：    \n（1）创建享元对象接口\npublic interface IFlyweight {    void print();}\n\n（2）创建具体享元对象\npublic class Flyweight implements IFlyweight {    private String id;    public Flyweight(String id){        this.id = id;    }    @Override    public void print() {        System.out.println(\"Flyweight.id = \" + getId() + \" ...\");    }    public String getId() {        return id;    }}\n\n（3）创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用HashMap中的key值保证其唯一。\npublic class FlyweightFactory {    private Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap();    public IFlyweight getFlyweight(String str){        IFlyweight flyweight = flyweightMap.get(str);        if(flyweight == null){            flyweight = new Flyweight(str);            flyweightMap.put(str, flyweight);        }        return  flyweight;    }    public int getFlyweightMapSize(){        return flyweightMap.size();    }}\n\n（4）测试，我们创建三个字符串，但是只会产生两个享元对象\npublic class MainTest {\tpublic static void main(String[] args) {        FlyweightFactory flyweightFactory = new FlyweightFactory();        IFlyweight flyweight1 = flyweightFactory.getFlyweight(\"A\");        IFlyweight flyweight2 = flyweightFactory.getFlyweight(\"B\");        IFlyweight flyweight3 = flyweightFactory.getFlyweight(\"A\");        flyweight1.print();        flyweight2.print();        flyweight3.print();        System.out.println(flyweightFactory.getFlyweightMapSize());    } }\n\n关系模式（11种)先来张图，看看这11中模式的关系：\n第一类：通过父类与子类的关系进行实现。\n第二类：两个类之间。\n第三类：类的状态。\n第四类：通过中间类  \n\n策略模式定义： 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。\n意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。\n策略模式结构和示例代码  抽象策略角色: 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。\n\n具体策略角色: 包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。\n环境角色: 内部会持有一个抽象角色的引用，给客户端调用。\n举例如下（ 实现一个加减的功能），类图如下：\n1、定义抽象策略角色\npublic interface Strategy { \tpublic int calc(int num1,int num2);}\n\n2、定义具体策略角色\npublic class AddStrategy implements Strategy { \t@Override\tpublic int calc(int num1, int num2) {\t\t// TODO Auto-generated method stub\t\treturn num1 + num2;\t} }public class SubstractStrategy implements Strategy { \t@Override\tpublic int calc(int num1, int num2) {\t\t// TODO Auto-generated method stub\t\treturn num1 - num2;\t} }\n\n3、环境角色\npublic class Environment {\tprivate Strategy strategy; \tpublic Environment(Strategy strategy) {\t\tthis.strategy = strategy;\t} \tpublic int calculate(int a, int b) {\t\treturn strategy.calc(a, b);\t} }\n\n4、测试\npublic class MainTest {\tpublic static void main(String[] args) {\t\t\t\tEnvironment environment=new Environment(new AddStrategy());\t\tint result=environment.calculate(20, 5);\t\tSystem.out.println(result);\t\t\t\tEnvironment environment1=new Environment(new SubstractStrategy());\t\tint result1=environment1.calculate(20, 5);\t\tSystem.out.println(result1);\t} }\n\n模板模式定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。\n通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。\n13.1 模式结构和代码示例\n：实现了模板方法，定义了算法的骨架。\n\n具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。\n举例（ 我们做菜可以分为三个步骤 （1）备料 （2）具体做菜 （3）盛菜端给客人享用，这三部就是算法的骨架 ；然而做不同菜需要的料，做的方法，以及如何盛装给客人享用都是不同的这个就是不同的实现细节。）。类图如下：\na. 先来写一个抽象的做菜父类：\npublic abstract class Dish {        /**     * 具体的整个过程     */    protected void dodish(){        this.preparation();        this.doing();        this.carriedDishes();    }    /**     * 备料     */    public abstract void preparation();    /**     * 做菜     */    public abstract void doing();    /**     * 上菜     */    public abstract void carriedDishes ();}\n\nb. 下来做两个番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法\npublic class EggsWithTomato extends Dish { \t@Override\tpublic void preparation() {\t\tSystem.out.println(\"洗并切西红柿，打鸡蛋。\");\t} \t@Override\tpublic void doing() {\t\tSystem.out.println(\"鸡蛋倒入锅里，然后倒入西红柿一起炒。\");\t} \t@Override\tpublic void carriedDishes() {\t\tSystem.out.println(\"将炒好的西红寺鸡蛋装入碟子里，端给客人吃。\");\t} }public class Bouilli extends Dish{     @Override    public void preparation() {        System.out.println(\"切猪肉和土豆。\");    }     @Override    public void doing() {        System.out.println(\"将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。\");    }     @Override    public void carriedDishes() {        System.out.println(\"将做好的红烧肉盛进碗里端给客人吃。\");    } }\n\nc. 在测试类中我们来做菜：\npublic class MainTest {\tpublic static void main(String[] args) {\t\tDish eggsWithTomato = new EggsWithTomato();\t\teggsWithTomato.dodish(); \t\tSystem.out.println(\"-----------------------------\"); \t\tDish bouilli = new Bouilli();\t\tbouilli.dodish();\t} }\n\n模板模式的优点和缺点优点：\n（1）具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。\n（2）代码复用的基本技术，在数据库设计中尤为重要。\n（3）存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”。\n缺点：每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。\n观察者模式定义： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n关键代码：在抽象类里有一个 ArrayList 存放观察者们。\n优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n模式结构图和代码示例\n抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。\n抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。\n具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。\n具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。\n举例（有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。）类图如下：\n1、定义一个抽象被观察者接口\npublic interface Subject {\t\t  public void registerObserver(Observer o);\t  public void removeObserver(Observer o);\t  public void notifyObserver(); }\n\n2、定义一个抽象观察者接口\npublic interface Observer {\t\tpublic void update(String message); }\n\n3、定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。\npublic class WechatServer implements Subject { \tprivate List&lt;Observer&gt; list;\tprivate String message; \tpublic WechatServer() {\t\tlist = new ArrayList&lt;Observer&gt;();\t} \t@Override\tpublic void registerObserver(Observer o) {\t\t// TODO Auto-generated method stub\t\tlist.add(o);\t} \t@Override\tpublic void removeObserver(Observer o) {\t\t// TODO Auto-generated method stub\t\tif (!list.isEmpty()) {\t\t\tlist.remove(o);\t\t}\t} \t@Override\tpublic void notifyObserver() {\t\t// TODO Auto-generated method stub\t\tfor (Observer o : list) {\t\t\to.update(message);\t\t}\t} \tpublic void setInfomation(String s) {\t\tthis.message = s;\t\tSystem.out.println(\"微信服务更新消息： \" + s);\t\t// 消息更新，通知所有观察者\t\tnotifyObserver();\t}}\n\n4、定义具体观察者，微信公众号的具体观察者为用户User\npublic class User implements Observer { \tprivate String name;\tprivate String message; \tpublic User(String name) {\t\tthis.name = name;\t} \t@Override\tpublic void update(String message) {\t\tthis.message = message;\t\tread();\t} \tpublic void read() {\t\tSystem.out.println(name + \" 收到推送消息： \" + message);\t} }\n\n5、编写一个测试类\npublic class MainTest {\t\t public static void main(String[] args) {\t\t \t        WechatServer server = new WechatServer();\t        \t        Observer userZhang = new User(\"ZhangSan\");\t        Observer userLi = new User(\"LiSi\");\t        Observer userWang = new User(\"WangWu\");\t        \t        server.registerObserver(userZhang);\t        server.registerObserver(userLi);\t        server.registerObserver(userWang);\t        server.setInfomation(\"PHP是世界上最好用的语言！\");\t        \t        System.out.println(\"----------------------------------------------\");\t        server.removeObserver(userZhang);\t        server.setInfomation(\"JAVA是世界上最好用的语言！\");\t        \t    } }\n\n迭代器模式定义：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。\n简单来说，不同种类的对象可能需要不同的遍历方式，我们对每一种类型的对象配一个迭代器，最后多个迭代器合成一个。\n主要解决：不同的方式来遍历整个整合对象。\n何时使用：遍历一个聚合对象。\n如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。\n关键代码：定义接口：hasNext, next。\n应用实例：JAVA 中的 iterator。\n优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。\n缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。\n15.1 模式结构和代码示例\n,\n\n(2)具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。\n(3)容器角色(Aggregate): 一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等\n(4)具体容器角色（ConcreteAggregate）：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。\n举例（咖啡厅和中餐厅合并，他们两个餐厅的菜单一个是数组保存的，一个是ArrayList保存的。遍历方式不一样，使用迭代器聚合访问，只需要一种方式）\n1 迭代器接口\npublic interface Iterator {\t\tpublic boolean hasNext();\tpublic Object next();\t}\n\n2 咖啡店菜单和咖啡店菜单遍历器\npublic class CakeHouseMenu {\tprivate ArrayList&lt;MenuItem&gt; menuItems;\t\t\tpublic CakeHouseMenu() {\t\tmenuItems = new ArrayList&lt;MenuItem&gt;();\t\t\t\taddItem(\"KFC Cake Breakfast\",\"boiled eggs&amp;toast&amp;cabbage\",true,3.99f);\t\taddItem(\"MDL Cake Breakfast\",\"fried eggs&amp;toast\",false,3.59f);\t\taddItem(\"Stawberry Cake\",\"fresh stawberry\",true,3.29f);\t\taddItem(\"Regular Cake Breakfast\",\"toast&amp;sausage\",true,2.59f);\t} \tprivate void addItem(String name, String description, boolean vegetable,\t\t\tfloat price) {\t\tMenuItem menuItem = new MenuItem(name, description, vegetable, price);\t\tmenuItems.add(menuItem);\t}\t \t\tpublic Iterator getIterator()\t{\t\treturn new CakeHouseIterator() ;\t}\t\tclass CakeHouseIterator implements  Iterator\t {\t\t\t\tprivate int position=0;\t\tpublic CakeHouseIterator()\t\t{\t\t\t  position=0;\t\t}\t\t\t\t \t@Override\t\t\tpublic boolean hasNext() {\t\t\t// TODO Auto-generated method stub\t\t\tif(position&lt;menuItems.size())\t\t\t{\t\t\t\treturn true;\t\t\t}\t\t\t\t\t\treturn false;\t\t} \t\t@Override\t\tpublic Object next() {\t\t\t// TODO Auto-generated method stub\t\t\tMenuItem menuItem =menuItems.get(position);\t\t\tposition++;\t\t\treturn menuItem;\t\t}};\t//鍏朵粬鍔熻兘浠ｇ爜\t}\n\n3 中餐厅菜单和中餐厅菜单遍历器\npublic class DinerMenu {\tprivate final static int Max_Items = 5;\tprivate int numberOfItems = 0;\tprivate MenuItem[] menuItems; \tpublic DinerMenu() {\t\tmenuItems = new MenuItem[Max_Items];\t\taddItem(\"vegetable Blt\", \"bacon&amp;lettuce&amp;tomato&amp;cabbage\", true, 3.58f);\t\taddItem(\"Blt\", \"bacon&amp;lettuce&amp;tomato\", false, 3.00f);\t\taddItem(\"bean soup\", \"bean&amp;potato salad\", true, 3.28f);\t\taddItem(\"hotdog\", \"onions&amp;cheese&amp;bread\", false, 3.05f); \t} \tprivate void addItem(String name, String description, boolean vegetable,\t\t\tfloat price) {\t\tMenuItem menuItem = new MenuItem(name, description, vegetable, price);\t\tif (numberOfItems &gt;= Max_Items) {\t\t\tSystem.err.println(\"sorry,menu is full!can not add another item\");\t\t} else {\t\t\tmenuItems[numberOfItems] = menuItem;\t\t\tnumberOfItems++;\t\t} \t} \tpublic Iterator getIterator() {\t\treturn new DinerIterator();\t} \tclass DinerIterator implements Iterator {\t\tprivate int position; \t\tpublic DinerIterator() {\t\t\tposition = 0;\t\t} \t\t@Override\t\tpublic boolean hasNext() {\t\t\t// TODO Auto-generated method stub\t\t\tif (position &lt; numberOfItems) {\t\t\t\treturn true;\t\t\t}\t\t\t\t\t\treturn false;\t\t} \t\t@Override\t\tpublic Object next() {\t\t\t// TODO Auto-generated method stub\t\t\tMenuItem menuItem = menuItems[position];\t\t\tposition++;\t\t\treturn menuItem;\t\t}\t};}\n\n4 女服务员\npublic class Waitress {\tprivate ArrayList&lt;Iterator&gt; iterators = new ArrayList&lt;Iterator&gt;(); \tpublic Waitress() { \t} \tpublic void addIterator(Iterator iterator) {\t\titerators.add(iterator); \t} \tpublic void printMenu() {\t\tIterator iterator;\t\tMenuItem menuItem;\t\tfor (int i = 0, len = iterators.size(); i &lt; len; i++) {\t\t\titerator = iterators.get(i); \t\t\twhile (iterator.hasNext()) {\t\t\t\tmenuItem = (MenuItem) iterator.next();\t\t\t\tSystem.out\t\t\t\t\t\t.println(menuItem.getName() + \"***\" + menuItem.getPrice() + \"***\" + menuItem.getDescription()); \t\t\t} \t\t} \t} \tpublic void printBreakfastMenu() { \t} \tpublic void printLunchMenu() { \t} \tpublic void printVegetableMenu() { \t}}\n\n责任链模式定义：如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。\n主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。\n何时使用：在处理消息的时候以过滤很多道。\n如何解决：拦截的类都实现统一接口。\n关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。\n模式的结构和代码示例\n抽象处理者（Handler)角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n举例（购买请求决策，价格不同要由不同的级别决定：组长、部长、副部、总裁）。类图如下：  1 决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数\n\npublic abstract class Approver {\t Approver successor;\t String Name;\tpublic Approver(String Name)\t{\t\tthis.Name=Name;\t}\tpublic abstract void ProcessRequest( PurchaseRequest request);\tpublic void SetSuccessor(Approver successor) {\t\t// TODO Auto-generated method stub\t\tthis.successor=successor;\t}}\n\n2 客户端以及请求\npublic class PurchaseRequest {\tprivate int Type = 0;\tprivate int Number = 0;\tprivate float Price = 0;\tprivate int ID = 0; \tpublic PurchaseRequest(int Type, int Number, float Price) {\t\tthis.Type = Type;\t\tthis.Number = Number;\t\tthis.Price = Price;\t} \tpublic int GetType() {\t\treturn Type;\t} \tpublic float GetSum() {\t\treturn Number * Price;\t} \tpublic int GetID() {\t\treturn (int) (Math.random() * 1000);\t}}public class Client { \tpublic Client() { \t} \tpublic PurchaseRequest sendRequst(int Type, int Number, float Price) {\t\treturn new PurchaseRequest(Type, Number, Price);\t}}\n\n3 组长、部长。。。继承决策者抽象类\npublic class GroupApprover extends Approver { \tpublic GroupApprover(String Name) {\t\tsuper(Name + \" GroupLeader\");\t\t// TODO Auto-generated constructor stub \t} \t@Override\tpublic void ProcessRequest(PurchaseRequest request) {\t\t// TODO Auto-generated method stub \t\tif (request.GetSum() &lt; 5000) {\t\t\tSystem.out.println(\"**This request \" + request.GetID() + \" will be handled by \" + this.Name + \" **\");\t\t} else {\t\t\tsuccessor.ProcessRequest(request);\t\t}\t} }public class DepartmentApprover extends Approver { \tpublic DepartmentApprover(String Name) {\t\tsuper(Name + \" DepartmentLeader\"); \t} \t@Override\tpublic void ProcessRequest(PurchaseRequest request) {\t\t// TODO Auto-generated method stub \t\tif ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) {\t\t\tSystem.out.println(\"**This request \" + request.GetID()\t\t\t\t\t+ \" will be handled by \" + this.Name + \" **\");\t\t} else {\t\t\tsuccessor.ProcessRequest(request);\t\t} \t} }\n\n4测试\npublic class MainTest { \tpublic static void main(String[] args) { \t\tClient mClient = new Client();\t\tApprover GroupLeader = new GroupApprover(\"Tom\");\t\tApprover DepartmentLeader = new DepartmentApprover(\"Jerry\");\t\tApprover VicePresident = new VicePresidentApprover(\"Kate\");\t\tApprover President = new PresidentApprover(\"Bush\"); \t\tGroupLeader.SetSuccessor(VicePresident);\t\tDepartmentLeader.SetSuccessor(President);\t\tVicePresident.SetSuccessor(DepartmentLeader);\t\tPresident.SetSuccessor(GroupLeader); \t\tGroupLeader.ProcessRequest(mClient.sendRequst(1, 10000, 40)); \t} }\n\n命令模式定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。\n意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n模式结构和代码示例\n1抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。2具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。3实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。4调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。代码举例（开灯和关灯），类图如下：\n1 命令抽象类\npublic interface Command {\t\tpublic void excute();\tpublic void undo(); }\n\n2 具体命令对象\npublic class TurnOffLight implements Command { \tprivate Light light; \tpublic TurnOffLight(Light light) {\t\tthis.light = light;\t} \t@Override\tpublic void excute() {\t\t// TODO Auto-generated method stub\t\tlight.Off();\t} \t@Override\tpublic void undo() {\t\t// TODO Auto-generated method stub\t\tlight.On();\t} }\n\n3 实现者\npublic class Light { \tString loc = \"\"; \tpublic Light(String loc) {\t\tthis.loc = loc;\t} \tpublic void On() { \t\tSystem.out.println(loc + \" On\");\t} \tpublic void Off() { \t\tSystem.out.println(loc + \" Off\");\t} }\n\n4 请求者\npublic class Contral{ \tpublic void CommandExcute(Command command) {\t\t// TODO Auto-generated method stub\t\tcommand.excute();\t} \tpublic void CommandUndo(Command command) {\t\t// TODO Auto-generated method stub\t\tcommand.undo();\t} }\n\n状态模式定义： 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。\n简单理解，一个拥有状态的context对象，在不同的状态下，其行为会发生改变。\n意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。\n何时使用：代码中包含大量与对象状态有关的条件语句。\n如何解决：将各种具体的状态类抽象出来。\n关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。\n优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。\n缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。\n模式结构和代码示例\nState抽象状态角色\n接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。\nConcreteState具体状态角色\n具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。\nContext环境角色\n定义客户端需要的接口，并且负责具体状态的切换。\n举例（人物在地点A向地点B移动，在地点B向地点A移动）。类图如下：\n1 state接口\npublic interface State {\tpublic void stop();\tpublic void move(); }\n\n2 状态实例\npublic class PlaceA implements State { \tprivate Player context; \tpublic PlaceA(Player context) {\t\tthis.context = context;\t} \t@Override\tpublic void move() {\t\tSystem.out.println(\"处于地点A,开始向B移动\");\t\tSystem.out.println(\"--------\");\t\tcontext.setDirection(\"AB\");\t\tcontext.setState(context.onMove); \t} \t@Override\tpublic void stop() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"正处在地点A，不用停止移动\");\t\tSystem.out.println(\"--------\");\t} }\n\n3 context(player)拥有状态的对象\npublic class Player { \tState placeA;\tState placeB;\tState onMove;\tprivate State state;\tprivate String direction; \tpublic Player() {\t\tdirection = \"AB\";\t\tplaceA = new PlaceA(this);\t\tplaceB = new PlaceB(this);\t\tonMove = new OnMove(this);\t\tthis.state = placeA;\t} \tpublic void move() {\t\tSystem.out.println(\"指令:开始移动\");\t\tstate.move();\t} \tpublic void stop() {\t\tSystem.out.println(\"指令:停止移动\");\t\tstate.stop();\t} \tpublic State getState() {\t\treturn state;\t} \tpublic void setState(State state) {\t\tthis.state = state;\t} \tpublic void setDirection(String direction) {\t\tthis.direction = direction;\t} \tpublic String getDirection() {\t\treturn direction;\t} }\n\n备忘录模式定义： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。\n备忘录模式是一种对象行为型模式，其主要优点如下。\n提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。\n实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。\n简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。\n其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。\n模式结构图和代码示例\n1发起人（Originator)角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。\n2备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。\n3管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。举例（发起者通过备忘录存储信息和获取信息），类图如下：\n1 备忘录接口\npublic interface MementoIF { }\n\n2 备忘录\npublic class Memento implements MementoIF{\t\tprivate String state; \tpublic Memento(String state) {\t\tthis.state = state;\t}\t\tpublic String getState(){\t\treturn state;\t}\t }\n\n3 发起者\npublic class Originator { \tprivate String state; \tpublic String getState() {\t\treturn state;\t} \tpublic void setState(String state) {\t\tthis.state = state;\t} \tpublic Memento saveToMemento() {\t\treturn new Memento(state);\t} \tpublic String getStateFromMemento(MementoIF memento) {\t\treturn ((Memento) memento).getState();\t} }\n\n4 管理者\npublic class CareTaker {\t\tprivate List&lt;MementoIF&gt; mementoList = new ArrayList&lt;MementoIF&gt;(); \tpublic void add(MementoIF memento) {\t\tmementoList.add(memento);\t} \tpublic MementoIF get(int index) {\t\treturn mementoList.get(index);\t} }\n\n访问者模式定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。\n访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。\n扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。\n灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。\n符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。\n访问者（Visitor）模式的主要缺点如下。\n增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\n破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。\n违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。\n模式结构和代码示例\n访问者模式包含以下主要角色。\n1抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。\n2具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。\n3抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。\n4具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。\n5对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。\n1 抽象访问者\npublic interface Visitor { \tabstract public void Visit(Element element);}\n\n2 具体访问者\npublic class CompensationVisitor implements Visitor { \t@Override\tpublic void Visit(Element element) {\t\t// TODO Auto-generated method stub\t\tEmployee employee = ((Employee) element); \t\tSystem.out.println(\t\t\t\temployee.getName() + \"'s Compensation is \" + (employee.getDegree() * employee.getVacationDays() * 10));\t} }\n\n3 抽象元素\npublic interface Element {\tabstract public void Accept(Visitor visitor); }\n\n4 具体元素\npublic class CompensationVisitor implements Visitor { \t@Override\tpublic void Visit(Element element) {\t\t// TODO Auto-generated method stub\t\tEmployee employee = ((Employee) element); \t\tSystem.out.println(\t\t\t\temployee.getName() + \"'s Compensation is \" + (employee.getDegree() * employee.getVacationDays() * 10));\t} }\n\n5 对象结构\npublic class ObjectStructure {\tprivate HashMap&lt;String, Employee&gt; employees; \tpublic ObjectStructure() {\t\temployees = new HashMap();\t} \tpublic void Attach(Employee employee) {\t\temployees.put(employee.getName(), employee);\t} \tpublic void Detach(Employee employee) {\t\temployees.remove(employee);\t} \tpublic Employee getEmployee(String name) {\t\treturn employees.get(name);\t} \tpublic void Accept(Visitor visitor) {\t\tfor (Employee e : employees.values()) {\t\t\te.Accept(visitor);\t\t}\t} }\n\n中介者模式定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。\n中介者模式是一种对象行为型模式，其主要优点如下。\n降低了对象之间的耦合性，使得对象易于独立地被复用。\n将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。\n其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。\n模式结构和代码示例角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\n\n具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\n抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\n具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\n举例（通过中介卖方），类图如下：\n1 抽象中介者\npublic interface Mediator { \tvoid register(Colleague colleague); // 客户注册 \tvoid relay(String from, String to,String ad); // 转发 }\n\n2 具体中介者\npublic class ConcreteMediator implements Mediator { \tprivate List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;(); \t@Override\tpublic void register(Colleague colleague) {\t\t// TODO Auto-generated method stub\t\tif (!colleagues.contains(colleague)) {\t\t\tcolleagues.add(colleague);\t\t\tcolleague.setMedium(this);\t\t}\t} \t@Override\tpublic void relay(String from, String to, String ad) {\t\t// TODO Auto-generated method stub\t\tfor (Colleague cl : colleagues) { \t\t\tString name = cl.getName();\t\t\tif (name.equals(to)) {\t\t\t\tcl.receive(from, ad);\t\t\t} \t\t} \t} }\n\n3 抽象同事类\npublic abstract class Colleague { \tprotected Mediator mediator;\tprotected String name; \tpublic Colleague(String name) {\t\tthis.name = name;\t} \tpublic void setMedium(Mediator mediator) { \t\tthis.mediator = mediator; \t} \tpublic String getName() {\t\treturn name;\t} \tpublic abstract void Send(String to, String ad); \tpublic abstract void receive(String from, String ad); }\n\n4 具体同事类\npublic class Buyer extends Colleague { \tpublic Buyer(String name) { \t\tsuper(name); \t} \t@Override\tpublic void Send(String to, String ad) {\t\t// TODO Auto-generated method stub\t\tmediator.relay(name, to, ad);\t} \t@Override\tpublic void receive(String from, String ad) {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(name + \"接收到来自\" + from + \"的消息:\" + ad);\t} }\n","categories":["TECHNOLOGY"],"tags":["Develop","Java","Crucial"]},{"title":"Pytorch余弦退火学习率","url":"/2023/05/27/Pytorch%E4%BD%99%E5%BC%A6%E9%80%80%E7%81%AB%E5%AD%A6%E4%B9%A0%E7%8E%87/","content":"CosineAnnealingLR\n特点是简单好用  [DOCS] [CODE] \n\ntorch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=0, last_epoch=- 1, verbose=False)\nparameter:\n\noptimizer (Optimizer)– Wrapped optimizer.\nT_max (int) – Maximum number of iterations.\neta_min (float) – Minimum learning rate. Default: 0.\nlast_epoch (int) – The index of last epoch. Default: -1.\nverbose (bool) – If True, prints a message to stdout for each update. Default: False.\n\nT_max决定学习率的波动周期，T_max=5时周期为5\n\n\n\nCosineAnnealingWarmRestarts\n[DOCS] [CODE]\n\ntorch.optim.lr_scheduler.CosineAnnealingWarmRestarts(optimizer, T_0, T_mult=1, eta_min=0, last_epoch=- 1, verbose=False)\nParameter:\n\noptimizer (Optimizer) – Wrapped optimizer.\nT_0 (int) – Number of iterations for the first restart.\nT_mult (int, optional) – A factor increases T_i after a restart. Default: 1.\neta_min (float, optional) – Minimum learning rate. Default: 0.\nlast_epoch (int, optional) – The index of last epoch. Default: -1.\nverbose (bool) – If True, prints a message to stdout for each update. Default: False.\n\n具体地说，\n\nT_0：学习率第一次回到初始值的epoch位置\nT_mult：控制学习率变化的速度。学习率在 T_0, (1 + T_mult)*T_0, (1 + T_mult + T_mult^2)*T_0 …处将回到初始值。\n\n\nCodeimport torchfrom torch.optim.lr_scheduler import CosineAnnealingLR,CosineAnnealingWarmRestarts,StepLRimport torch.nn as nnfrom torchvision.models import resnet18import matplotlib.pyplot as pltmodel=resnet18(pretrained=False)optimizer = torch.optim.SGD(model.parameters(), lr=0.1)mode='cosineAnnWarm''''以T_0=5, T_mult=1为例:T_0:学习率第一次回到初始值的epoch位置.T_mult:这个控制了学习率回升的速度\t- 如果T_mult=1,则学习率在T_0,2*T_0,3*T_0,....,i*T_0,....处回到最大值(初始学习率)\t\t- 5,10,15,20,25,.......处回到最大值\t- 如果T_mult&gt;1,则学习率在T_0,(1+T_mult)*T_0,(1+T_mult+T_mult**2)*T_0,.....，(1+T_mult+T_mult**2+...+T_0**i)*T0,处回到最大值\t\t- 5,15,35,75,155,.......处回到最大值example:\tT_0=5, T_mult=1'''if mode=='cosineAnn':    scheduler = CosineAnnealingLR(optimizer, T_max=5, eta_min=0)elif mode=='cosineAnnWarm':    scheduler = CosineAnnealingWarmRestarts(optimizer,T_0=5,T_mult=1)    plt.figure()epochs=50dataloader = Dataloader()cur_lr_list = []for epoch in range(epochs):\tfor (data, label) in enumerate(dataloader):\t\ttrain()\t\teval()        '''        这里scheduler.step(epoch + batch / iters)的理解如下,如果是一个epoch结束后再.step        那么一个epoch内所有batch使用的都是同一个学习率,为了使得不同batch也使用不同的学习率        则可以在这里进行.step        '''        # scheduler.step(epoch + batch / iters)        optimizer.step()    scheduler.step()    cur_lr=optimizer.param_groups[-1]['lr']    cur_lr_list.append(cur_lr)    print('cur_lr:',cur_lr)x_list = list(range(len(cur_lr_list)))plt.plot(x_list, cur_lr_list)plt.show()\n\n","categories":["TECHNOLOGY"],"tags":["Deep Learning","Pytorch"]},{"title":"优化算法Optimizer总结比较","url":"/2022/11/12/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95Optimizer%E6%80%BB%E7%BB%93%E6%AF%94%E8%BE%83/","content":"","tags":["Deep Learning","Pytorch"]}]